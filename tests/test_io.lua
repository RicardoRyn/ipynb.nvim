-- I/O round-trip tests for ipynb.nvim
-- Ensures notebooks are read and written without corruption
-- Run with: nvim --headless -u tests/minimal_init.lua -l tests/test_io.lua

local h = require('tests.helpers')

print('')
print(string.rep('=', 60))
print('Running I/O round-trip tests')
print(string.rep('=', 60))
print('')

local io_mod = require('ipynb.io')

--------------------------------------------------------------------------------
-- Source splitting tests (must match nbformat behavior)
-- Expected values generated by: uv run python tests/test_source_splitting.py
--------------------------------------------------------------------------------

-- Test cases: { name, source, expected_lines }
-- Expected values are from nbformat's actual output
local SOURCE_SPLIT_CASES = {
  { 'empty', '', {} },
  { 'single_line', 'x = 1', { 'x = 1' } },
  { 'single_line_trailing_newline', 'x = 1\n', { 'x = 1\n' } },
  { 'multi_line', 'x = 1\ny = 2', { 'x = 1\n', 'y = 2' } },
  { 'multi_line_trailing_newline', 'x = 1\ny = 2\n', { 'x = 1\n', 'y = 2\n' } },
  { 'three_lines', 'a\nb\nc', { 'a\n', 'b\n', 'c' } },
  { 'three_lines_trailing', 'a\nb\nc\n', { 'a\n', 'b\n', 'c\n' } },
  { 'blank_line_middle', 'a\n\nb', { 'a\n', '\n', 'b' } },
  { 'only_newline', '\n', { '\n' } },
  { 'multiple_newlines', '\n\n', { '\n', '\n' } },
  { 'unicode_emoji', 'üéâ = "party"', { 'üéâ = "party"' } },
  { 'unicode_japanese', 'x = "Êó•Êú¨Ë™û"', { 'x = "Êó•Êú¨Ë™û"' } },
}

-- Helper to compare arrays
local function arrays_equal(a, b)
  if #a ~= #b then
    return false, string.format('length mismatch: %d vs %d', #a, #b)
  end
  for i = 1, #a do
    if a[i] ~= b[i] then
      return false, string.format('element %d: %q vs %q', i, a[i], b[i])
    end
  end
  return true
end

-- Helper to get source lines from a written notebook
local function get_written_source_lines(source)
  local cells = {{ source = source, type = 'code', metadata = {}, outputs = {} }}
  local temp_path = vim.fn.tempname() .. '.ipynb'
  io_mod.write_ipynb(temp_path, cells, { nbformat = 4, nbformat_minor = 5 })

  local content = table.concat(vim.fn.readfile(temp_path), '\n')
  local notebook = vim.json.decode(content)
  vim.fn.delete(temp_path)

  return notebook.cells[1].source
end

-- Helper to get tests directory path
local function tests_dir()
  return vim.fn.fnamemodify(debug.getinfo(1, 'S').source:sub(2), ':p:h')
end

-- Helper to read raw JSON from file
local function read_json(path)
  local content = table.concat(vim.fn.readfile(path), '\n')
  return vim.json.decode(content)
end

-- Deep compare two tables, returning differences
local function deep_equal(a, b, path)
  path = path or ''

  if type(a) ~= type(b) then
    return false, string.format('%s: type mismatch (%s vs %s)', path, type(a), type(b))
  end

  if type(a) ~= 'table' then
    if a ~= b then
      return false, string.format('%s: value mismatch (%s vs %s)', path, vim.inspect(a), vim.inspect(b))
    end
    return true
  end

  -- Check all keys in a
  for k, v in pairs(a) do
    local new_path = path == '' and tostring(k) or (path .. '.' .. tostring(k))
    local ok, err = deep_equal(v, b[k], new_path)
    if not ok then
      return false, err
    end
  end

  -- Check for keys in b not in a
  for k, _ in pairs(b) do
    if a[k] == nil then
      local new_path = path == '' and tostring(k) or (path .. '.' .. tostring(k))
      return false, string.format('%s: missing in first table', new_path)
    end
  end

  return true
end

--------------------------------------------------------------------------------
-- Test: Source splitting matches nbformat behavior
-- This is critical for compatibility with Jupyter and other tools
--------------------------------------------------------------------------------
h.run_test('source_splitting_matches_nbformat', function()
  for _, case in ipairs(SOURCE_SPLIT_CASES) do
    local name, source, expected = case[1], case[2], case[3]
    local actual = get_written_source_lines(source)

    local ok, err = arrays_equal(actual, expected)
    if not ok then
      error(string.format('source_split %s: %s\n  source: %q\n  expected: %s\n  actual: %s',
        name, err, source, vim.inspect(expected), vim.inspect(actual)))
    end
  end
end)

--------------------------------------------------------------------------------
-- Test: Basic round-trip preserves cell source
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_cell_source', function()
  local path = tests_dir() .. '/fixtures/simple.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  -- Read original
  local cells, metadata = io_mod.read_ipynb(path)

  -- Store original sources
  local original_sources = {}
  for i, cell in ipairs(cells) do
    original_sources[i] = cell.source
  end

  -- Write to temp
  io_mod.write_ipynb(temp_path, cells, metadata)

  -- Read back
  local cells2, _ = io_mod.read_ipynb(temp_path)

  -- Compare cell sources
  h.assert_eq(#cells2, #cells, 'Cell count should match')
  for i, cell in ipairs(cells2) do
    h.assert_eq(cell.source, original_sources[i], string.format('Cell %d source should match', i))
  end

  -- Cleanup
  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Round-trip preserves cell types
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_cell_types', function()
  local path = tests_dir() .. '/fixtures/mixed.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local cells, metadata = io_mod.read_ipynb(path)

  local original_types = {}
  for i, cell in ipairs(cells) do
    original_types[i] = cell.type
  end

  io_mod.write_ipynb(temp_path, cells, metadata)
  local cells2, _ = io_mod.read_ipynb(temp_path)

  for i, cell in ipairs(cells2) do
    h.assert_eq(cell.type, original_types[i], string.format('Cell %d type should match', i))
  end

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Metadata preservation (kernelspec)
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_kernelspec', function()
  local path = tests_dir() .. '/fixtures/mixed.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)

  local raw = read_json(temp_path)

  h.assert_eq(raw.metadata.kernelspec.name, 'python3', 'Kernelspec name preserved')
  h.assert_eq(raw.metadata.kernelspec.display_name, 'Python 3', 'Kernelspec display_name preserved')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Rich metadata preservation (Colab, accelerator, widgets)
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_rich_metadata', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  -- Check Colab metadata preserved
  h.assert_true(written.metadata.colab ~= nil, 'Colab metadata should be preserved')
  h.assert_eq(written.metadata.colab.gpuType, 'T4', 'Colab gpuType should be preserved')

  -- Check accelerator preserved
  h.assert_eq(written.metadata.accelerator, 'GPU', 'Accelerator should be preserved')

  -- Check widgets preserved
  h.assert_true(written.metadata.widgets ~= nil, 'Widgets metadata should be preserved')

  -- Check language_info preserved with all fields
  h.assert_eq(written.metadata.language_info.file_extension, '.py', 'language_info.file_extension preserved')
  h.assert_eq(written.metadata.language_info.mimetype, 'text/x-python', 'language_info.mimetype preserved')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Cell ID preservation (nbformat 4.5+)
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_cell_ids', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  -- Check each cell ID is preserved
  for i, orig_cell in ipairs(original.cells) do
    h.assert_eq(written.cells[i].id, orig_cell.id,
      string.format('Cell %d ID should be preserved (%s)', i, orig_cell.id))
  end

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Cell metadata preservation
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_cell_metadata', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  -- Check cell metadata preserved
  h.assert_eq(written.cells[1].metadata.id, 'colab_cell_1', 'Cell 1 Colab ID preserved')
  h.assert_true(written.cells[1].metadata.tags ~= nil, 'Cell 1 tags preserved')
  h.assert_eq(written.cells[1].metadata.tags[1], 'intro', 'Cell 1 tag value preserved')

  -- Check execution metadata
  h.assert_true(written.cells[2].metadata.executionInfo ~= nil, 'executionInfo preserved')
  h.assert_eq(written.cells[2].metadata.scrolled, true, 'scrolled metadata preserved')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Output preservation
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_outputs', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  -- Check outputs preserved
  h.assert_eq(#written.cells[2].outputs, 1, 'Output count preserved')
  h.assert_eq(written.cells[2].outputs[1].output_type, 'stream', 'Output type preserved')
  h.assert_eq(written.cells[2].outputs[1].name, 'stdout', 'Output name preserved')
  h.assert_eq(written.cells[2].outputs[1].text[1], 'hello\n', 'Output text preserved')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Execution count preservation
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_execution_count', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  h.assert_eq(written.cells[2].execution_count, 1, 'Execution count preserved')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Empty cell handling
--------------------------------------------------------------------------------
h.run_test('roundtrip_handles_empty_cells', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  -- Cell 3 (index 2 in 0-based) is empty
  h.assert_eq(#written.cells[3].source, 0, 'Empty cell has empty source array')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Unicode preservation
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_unicode', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local cells, metadata = io_mod.read_ipynb(path)

  -- Find unicode cell (cell 4, 0-indexed)
  local unicode_cell = cells[4]
  h.assert_true(unicode_cell.source:find('üéâ') ~= nil, 'Unicode emoji in source')
  h.assert_true(unicode_cell.source:find('Êó•Êú¨Ë™û') ~= nil, 'Japanese in source')
  h.assert_true(unicode_cell.source:find('‚à´‚àë‚àè') ~= nil, 'Math symbols in source')

  io_mod.write_ipynb(temp_path, cells, metadata)
  local cells2, _ = io_mod.read_ipynb(temp_path)

  h.assert_eq(cells2[4].source, unicode_cell.source, 'Unicode preserved through round-trip')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Trailing newline handling
--------------------------------------------------------------------------------
h.run_test('roundtrip_handles_trailing_newlines', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  -- Cell 5 (index 4 in 0-based) has trailing newline
  -- Original source array ends with "\n"
  local orig_last = original.cells[5].source[#original.cells[5].source]
  local written_last = written.cells[5].source[#written.cells[5].source]

  -- Both should end the same way
  h.assert_eq(written_last:sub(-1), orig_last:sub(-1),
    'Trailing newline handling consistent')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: nbformat version preservation
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_nbformat', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  h.assert_eq(written.nbformat, original.nbformat, 'nbformat preserved')
  h.assert_eq(written.nbformat_minor, original.nbformat_minor, 'nbformat_minor preserved')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Read-back produces valid JSON
--------------------------------------------------------------------------------
h.run_test('written_notebook_is_valid_json', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)

  -- Should not throw
  local ok, result = pcall(read_json, temp_path)
  h.assert_true(ok, 'Written file should be valid JSON')
  h.assert_true(result.cells ~= nil, 'Should have cells array')
  h.assert_true(result.metadata ~= nil, 'Should have metadata')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Can read back what we wrote
--------------------------------------------------------------------------------
h.run_test('can_read_written_notebook', function()
  local path = tests_dir() .. '/fixtures/simple.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)

  -- Should be able to read it back without error
  local ok, err = pcall(function()
    local cells2, metadata2 = io_mod.read_ipynb(temp_path)
    return cells2, metadata2
  end)

  h.assert_true(ok, 'Should be able to read written notebook: ' .. tostring(err))

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: All fixtures round-trip successfully
--------------------------------------------------------------------------------
h.run_test('all_fixtures_roundtrip', function()
  local fixtures = {
    'simple.ipynb',
    'mixed.ipynb',
    'three_cells.ipynb',
    'lsp_test.ipynb',
    'rich_metadata.ipynb',
  }

  for _, fixture in ipairs(fixtures) do
    local path = tests_dir() .. '/fixtures/' .. fixture
    local temp_path = vim.fn.tempname() .. '.ipynb'

    local ok, err = pcall(function()
      local cells, metadata = io_mod.read_ipynb(path)
      io_mod.write_ipynb(temp_path, cells, metadata)
      local cells2, metadata2 = io_mod.read_ipynb(temp_path)

      -- Basic sanity checks
      assert(#cells2 == #cells, fixture .. ': cell count mismatch')
      for i, cell in ipairs(cells) do
        assert(cells2[i].source == cell.source, fixture .. ': cell ' .. i .. ' source mismatch')
        assert(cells2[i].type == cell.type, fixture .. ': cell ' .. i .. ' type mismatch')
      end
    end)

    h.assert_true(ok, fixture .. ' should round-trip: ' .. tostring(err))
    vim.fn.delete(temp_path)
  end
end)

--------------------------------------------------------------------------------
-- Test: jupytext format round-trip (facade buffer format)
--------------------------------------------------------------------------------
h.run_test('jupytext_format_roundtrip', function()
  local original_cells = {
    { type = 'markdown', source = '# Header\n\nSome text', metadata = {} },
    { type = 'code', source = 'x = 1\ny = 2', metadata = {}, outputs = {} },
    { type = 'code', source = '', metadata = {}, outputs = {} },  -- empty cell
  }

  local lines = io_mod.cells_to_jupytext(original_cells)
  local parsed_cells = io_mod.jupytext_to_cells(lines)

  h.assert_eq(#parsed_cells, #original_cells, 'Cell count matches')

  for i, orig in ipairs(original_cells) do
    h.assert_eq(parsed_cells[i].type, orig.type, 'Cell ' .. i .. ' type matches')
    h.assert_eq(parsed_cells[i].source, orig.source, 'Cell ' .. i .. ' source matches')
  end
end)

--------------------------------------------------------------------------------
-- Print summary and exit
--------------------------------------------------------------------------------
local success = h.summary()
if success then
  vim.cmd('qa!')
else
  vim.cmd('cquit 1')
end
